/******** DO NOT EDIT THIS FILE ********/
#ifndef _JOBQUEUE_H
#define _JOBQUEUE_H
#include <stddef.h>
#include <stdbool.h>
#include "sim_config.h"
#include "job.h"

/* 
 * Introduction
 *
 * The job queue implementation uses a fixed sized job_t array as a circular
 * buffer.
 *
 * The jobqueue_t (alias for struct jobqueue) encapsulates the state of the
 * queue: head position, tail position, size and job_t buffer of jobs.
 *
 * The job queue is a FIFO queue, jobs are enqueued at the tail of the queue 
 * and dequeued at the head.
 *
 * The functions:
 *      jobqueue_init
 *      jobqueue_new
 *      jobqueue_capacity
 *      jobqueue_dequeue
 *      jobqueue_enqueue
 *      jobqueue_is_empty
 *      jobqueue_is_full
 *      jobqueue_peekhead
 *      jobqueue_peektail
 *      jobqueue_delete
 *
 * provide the operations on a jobqueue_t to create and initialise it, 
 * to test its state (empty, full, element at head and element at tail), 
 * to remove entries (dequeue), to add entries (enqueue) and to deallocate
 * resources associated with the queue.
 *
 * Together the functions above maintain the integrity of a job queue for
 * for single process access.
 *
 * IMPORTANT:
 * Only operate on a jobqueue using the functions defined in 
 * this file. Using a jobqueue in any other way can result in undefined 
 * and erroneous behaviour.
 */

/* 
 * Definition of struct jobqueue that can be used as the basic data structure
 * for sharing definitions of jobs between cooperating processes. 
 *
 * Type alias:
 * A struct jobqueue can also be referred to as jobqueue_t
 *
 * Fields:
 * head - the buffer index of the head of the queue
 * tail - the buffer index of the tail of the queue
 * buf_size - the size of the underlying buffer
 * jobs - the fixed sized buffer of job descriptions (job_t types) 
 *
 * Note fields of the struct should only be accessed in the implementation 
 * file jobqueue.c
 *
 * See also:
 * job.h - for information about the job descriptor type (job_t).
 * sim_config.h - for specification of fixed queue size: QUEUE_SIZE
 *
 * Type aliasing means that jobqueue_t can be used as an alias for 
 * "struct jobqueue".
 */
typedef struct jobqueue {
    int head;
    int tail;
    int buf_size;
    job_t jobs[QUEUE_SIZE];
} jobqueue_t;

/*
 * jobqueue_init(jobqueue_t* jq)
 *
 * Initialise a jobqueue to the following values:
 *      head - 0
 *      tail - 0
 *      buf_size - QUEUE_SIZE
 * and each job in the buffer will have pid 0, id 0 and zeroed label array 
 * (each element of each job's label array will have the value).
 *
 * jobqueue_init is a utility function to facilitate initialisation of 
 * shared memory versions of a jobqueue (see ipc_jobqueue). For single process
 * versions, jobqueue_new allocates and initialises the queue.
 * 
 * Calling jobqueue_init on a queue that is in use will empty the queue.
 * That is, the function can be used to initialise and re-initialise a queue.
 *
 * Calling a jobqueue_init with a NULL queue will cause a memory error.
 *
 * Usage:
 *      jobqueue_t* jq = ...              // create a jobqueue by some means
 *      jobqueue_init(jq);                // initialise the jobqueue
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue to initialise
 *
 * Errors:
 * If jq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that jq is not NULL.
 */
void jobqueue_init(jobqueue_t* jq);

/*
 * jobqueue_new()
 *
 * Dynamically allocates and initialise a jobqueue.
 *
 * Usage:
 *      jobqueue_t* jq = jobqueue_new();   // allocate a new job queue
 *      ...                          
 *      ...
 *      jobqueue_delete(jq);               // delete the queue and release
 *                                         // resources associated with it
 *
 * Return:
 * On success: a new non-null pointer to a dynamically allocated jobqueue.
 *      Use jobqueue_delete to free memory allocated to the jobqueue.
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned and errno will be 
 * set as specified by system library dynamic memory allocation functions.
 * 
 * See also:
 * jobqueue_init - for a description of initialisation of a jobqueue
 * job.h - for a description of the job type
 * man pages for malloc
 */
jobqueue_t* jobqueue_new();

/*
 * jobqueue_capacity(jobqueue_t* jq)
 *
 * Returns the capacity of the given queue - the maximum number of jobs that 
 * the queue can contain. A queue's capacity is set at its creation. It is 
 * not a count of the empty slots.
 *
 * Usage:
 *      jobqueue_t* jq = jobqueue_new();
 *      int c = jobqueue_capacity(jq);     // get the queue's capacity
 *      printf("%d\n", c);                 // and print it to stdout                           
 *      ...
 *      jobqueue_delete(jq);
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 *
 * Return:
 * The capacity of the queue, which will be >= 1 if jq is not NULL. If jq is
 * NULL, the capacity will be 0.
 */
size_t jobqueue_capacity(jobqueue_t* jq);

/* 
 * jobqueue_dequeue(jobqueue_t* jq, job_t* dst)
 *
 * If the queue is not empty, dequeues the job at the head of the queue (the
 * oldest job in the queue). If dst is not NULL, the job at the head of the 
 * queue is copied to the job pointed to by dst. If dst is NULL, the job
 * at the head of the queue is copied to a new, dynamically allocated job. A 
 * pointer to the copy is returned. On return of the function, the head of the 
 * queue will be the next job in the queue (or the queue is empty if the 
 * job dequeued was the only entry in the queue). The job in the queue's buffer
 * that was previously at the head of the queue will be initialised
 * (with pid 0, id 0 and label zeroed).
 * 
 * If the queue is empty, the function returns NULL. Calling dequeue on an 
 * empty queue has no effect on the state of the queue. Similarly, this 
 * function has no effect if jq is NULL.
 * 
 * The user of this function can avoid the return of a NULL pointer by 
 * checking that the queue is not empty before calling dequeue.
 *
 * Usage:
 *      jobqueue_t* jq = jobqueue_new(); 
 *      job_t dst;   
 *      ...
 *      ...
 *      // dequeue jobs as long as the queue is not empty, copying each 
 *      // dequeued job to the local variable dst:
 *      while (!jobqueue_is_empty(jq)) {     
 *          job_t* j = jobqueue_dequeue(jq, &dst); // j will point to dst
 *          ...
 *          ...
 *      }
 *      ...
 *      ...
 *      jobqueue_delete(jq); 
 * 
 *      // alternative approach with dynamic allocation of the copy of
 *      // dequeued job
 *      jobqueue_t* jq = jobqueue_new(); 
 *      ...
 *      ...
 *      // dequeue jobs as long as the queue is not empty, copying each 
 *      // dequeued job to a new, dynamically allocated job
 *      while (!jobqueue_is_empty(jq)) {     
 *          job_t* j = jobqueue_dequeue(jq, NULL); // j points to a new job
 *          ...
 *          ...
 *          job_delete(j);  // necessary because of dynamic allocation of j
 *      }
 *      ...
 *      ...
 *      jobqueue_delete(jq); 
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 * dst - a pointer to the job to copy to, which may be NULL 
 *
 * Return:
 * A pointer to copy of the job that was at the head of the queue or, 
 * if the queue is empty, the NULL pointer. If the dst paremter is not NULL, 
 * the job is to the job pointed to by dst and the dst pointer is returned. If
 * dst is NULL, a new job is dynamically allocated and copied to and a pointer
 * to the new job returned.
 * If jq is NULL, this function has no effect and the NULL pointer is returned.
 *
 * Important note:
 * If the queue was not empty, after the return of this function, the 
 * job in the queue's buffer at what was the head position will have been
 * initialised (with pid 0, id 0 and zeroed label) and the head position will 
 * have been advanced to the next job in the queue's buffer. This may result in 
 * an empty queue.
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
job_t* jobqueue_dequeue(jobqueue_t* jq, job_t* dst);

/*
 * jobqueue_enqueue(jobqueue_t* jq, job_t* job)
 *
 * If the queue is not full, enqueues the given job on the given queue.
 * The job pointed to by the parameter passed to the function is copied
 * to the tail of the queue.
 *
 * If the queue jq is full, this function has no effect on the state of the 
 * the queue. Similarly, if jq or job pointers are NULL, this function has
 * no effect.
 *
 * Important note:
 * This function gives no indication that the queue is full. It silently
 * fails if the queue is full. It is therefore the application 
 * programmer's responsibility to check whether the queue is full 
 * before calling this function.
 *
 * Usage:
 *      jobqueue_t* jq = jobqueue_new();
 *      job_t job;                          // local job variable
 *      ...
 *      ...
 *      // enqueue jobs as long as the queue is not full
 *      while (!jobqueue_is_full(jq)) {  
 *          job_t* j = job_set(&job, ...); // set fields of local job   
 *          jobqueue_enqueue(jq, j);  
 *          ...
 *          ...
 *      }
 *      ...
 *      ...
 *      jobqueue_delete(jq);  
 *
 *      // alternative approach with dynamic allocation of the job to 
 *      // enqueue
 *      jobqueue_t* jq = jobqueue_new();    
 *      ...
 *      ...
 *      // enqueue jobs as long as the queue is not full
 *      while (!jobqueue_is_full(jq)) {  
 *          job_t* j = job_new(...);    // dynamically allocate and set a job    
 *          jobqueue_enqueue(jq, j);  
 *          job_delete(j);              // delete job after enqueuing, a copy
 *          ...                         // is on the queue
 *          ...
 *          ...
 *      }
 *      ...
 *      ...
 *      jobqueue_delete(jq);  
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 * job - a non-null pointer to a job to copy to the queue
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
void jobqueue_enqueue(jobqueue_t* jq, job_t* job);

/*
 * jobqueue_is_empty(jobqueue_t* jq)
 *
 * Returns true if the queue is empty, all slots are unused, and false
 * otherwise. A NULL queue is considered empty.
 *
 * Usage: see jobqueue_dequeue
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 *
 * Return:
 * True if the queue is empty, false otherwise.
 * 
 * If jq is NULL, the queue is considered empty. This guarantees the semantics
 * of the jobqueue_dequeue - ensuring that a job cannot be dequeued from a 
 * NULL queue.
 */
bool jobqueue_is_empty(jobqueue_t* jq);

/* 
 * jobqueue_is_full(jobqueue_t* jq)
 *
 * Returns true if the queue is full, the number of jobs in the queue has 
 * reached its capacity, and false otherwise. A NULL queue is considered full.
 *
 * Usage: see jobqueue_enqueue
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 *
 * Return:
 * True if the queue is full, false otherwise.
 *
 * If jq is NULL, the queue is considered full. This guarantees the semantics
 * of the jobqueue_enqueue - ensuring that a job cannot be enqueued on a 
 * NULL queue.
 */
bool jobqueue_is_full(jobqueue_t* jq);

/*
 * jobqueue_peekhead(jobqueue_t* jq, job_t* dst)
 *
 * If the queue is not empty, copies the job at the head of the queue to the  
 * job pointed to by dst (if dst is not NULL). If dst is NULL, a new job is 
 * dynamically allocated and the job at the head of the queue is copied to it.
 * Whether dst is NULL or not, the function returns a pointer to the copy 
 * (which will be dst if dst is not NULL).
 * If the queue is empty, the function returns the NULL pointer. The caller can
 * check whether the queue is empty prior to calling jobqueue_peekhead to
 * avoid this.
 *
 * The returned pointer is to a copy of the job at the head of the queue. It
 * is not the same job in memory as the job at the head of the queue. That is, 
 * it is semantically equal to the job at the head of the queue but not 
 * identical to it in memory.
 *
 * This function does not change the state of the queue and, if changes are 
 * subsequently made to the copied job, the changes will not be reflected in 
 * the job at the head of the queue.
 *
 * Usage:
 *      jobqueue_t* jq = jobqueue_new();
 *      job_t dst;                  // local variable to copy to
 *      ...    
 *      ...
 *      if (!jobqueue_is_empty(jq))
 *          job_t* job_at_head = jobqueue_peekhead(jq, &dst);  
 *                                  // the queue's state is unchanged 
 *                                  // the original copy of job_at_head 
 *                                  // remains on the queue, job_at_head points 
 *                                  // to the copy dst
 *      ...
 *      ...
 *      jobqueue_delete(jq);  
 *
 *      // alternative approach with dynamic allocation of the job to 
 *      // copy to
 *      jobqueue_t* jq = jobqueue_new();
 *      ...    
 *      ...
 *      if (!jobqueue_is_empty(jq))
 *          job_t* job_at_head = jobqueue_peekhead(jq, NULL);  
 *                                  // the queue's state is unchanged 
 *                                  // the original copy of job_at_head 
 *                                  // remains on the queue, job_at_head is
 *                                  // dynamically allocated because dst is 
 *                                  // NULL
 *      ...
 *      ...
 *      job_delete(job_at_head);
 *      jobqueue_delete(jq);  
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 * dst - a pointer to a job to copy to, which may be NULL
 *
 * Return:
 * A pointer to a copy of the job at the head of the queue or NULL
 * if the queue is empty or jq is NULL.
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
job_t* jobqueue_peekhead(jobqueue_t* jq, job_t* dst);

/*
 * jobqueue_peektail(jobqueue_t* jq)
 *
 * If the queue is not empty, copies the job at the tail of the queue to the  
 * job pointed to by dst (if dst is not NULL). If dst is NULL, a new job is 
 * dynamically allocated and the job at the tail of the queue is copied to it.
 * Whether dst is NULL or not, the function returns a pointer to the copy 
 * (which will be dst if dst is not NULL).
 * If the queue is empty, the function returns the NULL pointer. The caller can
 * check whether the queue is empty prior to calling jobqueue_peekhead to
 * avoid this.
 *
 * The returned pointer is to a copy of the job at the tail of the queue. It
 * is not the same job in memory as the job at the tail of the queue. That is, 
 * it is semantically equal to the job at the tail of the queue but not 
 * identical to it in memory.
 *
 * This function does not change the state of the queue and, if changes are 
 * subsequently made to the copied job, the changes will not be reflected in 
 * the job at the tail of the queue.
 *
 * Usage:
 *      jobqueue_t* jq = jobqueue_new();
 *      job_t dst;                  // local variable to copy to
 *      ...    
 *      ...
 *      if (!jobqueue_is_empty(jq))
 *          job_t* job_at_tail = jobqueue_peektail(jq, &dst);  
 *                                  // the queue's state is unchanged 
 *                                  // the original copy of job_at_tail
 *                                  // remains on the queue, job_at_tail points 
 *                                  // to the copy dst
 *      ...
 *      ...
 *      jobqueue_delete(jq);  
 *
 *      // alternative approach with dynamic allocation of the job to 
 *      // copy to
 *      jobqueue_t* jq = jobqueue_new();
 *      ...    
 *      ...
 *      if (!jobqueue_is_empty(jq))
 *          job_t* job_at_tail = jobqueue_peektail(jq, NULL);  
 *                                  // the queue's state is unchanged 
 *                                  // the original copy of job_at_tail 
 *                                  // remains on the queue, job_at_tail is
 *                                  // dynamically allocated because dst is 
 *                                  // NULL
 *      ...
 *      ...
 *      job_delete(job_at_tail);
 *      jobqueue_delete(jq);  
 *
 * Parameters:
 * jq - a non-null pointer to a jobqueue
 * dst - a pointer to a job to copy to, which may be NULL
 *
 * Return:
 * A pointer to a copy of the job at the tail of the queue or NULL if the queue
 * is empty or jq is NULL.
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
job_t* jobqueue_peektail(jobqueue_t* jq, job_t* dst);

/*
 * jobqueue_delete(jobqueue_t* jq)
 * 
 * This function frees resources allocated by jobqueue_new.
 *
 * Parameters:
 * jq - a non-null pointer to the queue to delete
 *
 * Return:
 * There is no return value for the function. If jq is not NULL and the call 
 * succeeds, the queue will be freed. If jq is NULL this function has no effect.
 */
void jobqueue_delete(jobqueue_t* jq);

#endif