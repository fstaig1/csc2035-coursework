/******** DO NOT EDIT THIS FILE ********/
#ifndef _JOB_H
#define _JOB_H
#include <stdbool.h>
#include <unistd.h>
#include "sim_config.h"

/* 
 * Definition of struct job - for entry on a jobqueue and logging to a joblog.
 *
 * Fields:
 * pid - the process id of the producer that created the job. Process ids
 *      should be unique for a given host.
 * id - the job id. Job ids are generated locally by the job producer process 
 *      and can be made unique for that producer process. 
 * label - a character array of size MAX_NAME_SIZE to hold an 
 *      application-specific string label of length exactly MAX_NAME_SIZE - 1.
 *      the job_new, job_copy and job_set functions guarantee that the 
 *      label field will be a string of length MAX_NAME_SIZE - 1.
 * 
 * The combination of job.pid and job.id can be used to ensure globally unique  
 * jobs for a given host. That is, a pid uniquely identifies a process and a 
 * producer can ensure that the job ids it generates are unique.
 *
 * See also:
 * job_new, job_copy, job_set and job_delete - for information on creation
 *      and destruction of job objects
 * sim_config.h - for specification of the maximum shared object name: 
 *      MAX_NAME_SIZE
 *
 * Type aliasing means that job_t can be used as an alias for "struct job".
 */
typedef struct job {
    pid_t pid;
    unsigned int id;
    char label[MAX_NAME_SIZE];
} job_t;

/*
 * job_new(pid_t pid, unsigned int id, const char* label)
 * 
 * Creates a new (dynamically allocated) job struct with the given producer
 * process id, job id and label.
 * 
 * The label can be any application-specific string of up to MAX_NAME_SIZE - 1
 * characters. If the given label is less than length MAX_NAME_SIZE - 1, then
 * the label associated with the job is padded with PAD_CHAR characters up to
 * length MAX_NAME_SIZE - 1. If the given label string is longer than
 * MAX_NAME_SIZE - 1, then the label associated with the job is truncated to
 * length MAX_NAME_SIZE - 1. Padding or truncation ensure that the label stored
 * with a job is exactly length MAX_NAME_SIZE - 1. The job_new, job_copy and  
 * job_set functions all guarantee this property of the label.
 * 
 * If the label parameter is the empty string or is NULL, the label field
 * of the job will be a MAX_NAME_SIZE - 1 length string of PAD_CHAR characters.
 * 
 * PAD_CHAR is defined in sim_config.h.
 *
 * Usage:
 *      pid_t pid = getpid();   // use system call getpid to get proces id 
 *      job_t* job = job_new(pid, 1, "newjob");
 *                      // creates new job with given pid, id of 1 and label
 *                      // "newjob", which will be padded to length 
 *                      // MAX_NAME_SIZE - 1
 *      ...                         
 *      ...
 *      job_delete(job);    // delete this instance of the job struct
 *
 * Parameters:
 * pid - the id of the process creating the job (typically, this is the system 
 *      allocated process id that can be obtained using getpid)
 * id - an id for the job generated by the calling process
 * label - the  application-specific label for the job.
 *
 * Return:
 * On success: a new non-NULL pointer to a dynamically allocated job struct.
 *      The job_new function guarantees that the label field of the job struct
 *      is a string of length exactly MAX_NAME_SIZE - 1, padded with PAD_CHAR 
 *      characters if necessary. If the label parameter is the empty string or
 *      NULL, the  stored label field will be all PAD_CHAR characters. 
 *      Use job_delete to free memory allocated to the job struct.  
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned. errno is set as 
 * specified by system library functions used to implement the function (see
 * below).
 * 
 * See also:
 * man page for malloc, used to allocate the new job
 * sim_config.h - for specification of the maximum name size: MAX_NAME_SIZE 
 *      and padding character: PAD_CHAR
 */
job_t* job_new(pid_t pid, unsigned int id, const char* label);

/*
 * job_copy(job_t* dst, job_t* src)
 * 
 * Copy from job src to job dst. Assuming the pointers dst and src are 
 * distinct, after copying, src and dst jobs will be distinct objects in memory
 * that are semantically equal as specified by the job_is_equal comparison. 
 * That is, the fields of the jobs pointed to by  dst and src will be equal. 
 * A pointer to the copy is returned. 
 *
 * Combinations of dst and src pointer values are dealt with as follows:
 *      1. If src is NULL, the function returns NULL. 
 *      2. If src and dst pointers are identical, i.e. point to the same 
 *         object in memory, a job pointer is returned without any copying.
 *      3. If dst is NULL, a new job is dynamically allocated, the job pointed
 *         to by src is copied to the new job and a pointer to the new job is 
 *         returned. 
 *      4. If dst is not NULL and not identical to src, the job pointed to by 
 *         src is copied to the job pointed to by dst and the dst pointer is 
 *         returned.
 *
 * In effect, in all cases, a pointer to the job copied to is returned (albeit
 * the pointer may be NULL).
 *
 * The properties of the label field are preserved by this function. That is,
 * the job's label field will be a string of length exactly MAX_NAME_SIZE - 
 * (with padding or truncation as necessary).
 *
 * Parameters:
 * dst - the address of the job to copy to or NULL if a new copy is to be
 *      dynamically allocated 
 * src - a non-NULL pointer to a job to copy from
 *
 * Return:
 * On success: a pointer to the copied object (the dst pointer). If dst is NULL
 *      a new, dynamically allocated copy of src is created.
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned. errno is set in the 
 * circumstances specified for job_new.
 */
job_t* job_copy(job_t* dst, job_t* src);

/*
 * job_is_equal(job_t* j1, job_t* j2)
 * 
 * Tests whether the two jobs, j1 and j2, are equal. The jobs are considered 
 * equal if their pid fields are equal and their id fields are equal and their 
 * labels are equal.
 *
 * Usage:
 *      job_t* j1 = job_new(1, 2, "label1"};
 *      job_t* j2 = job_new(1, 2, "label1"};
 *      job_t* j3 = job_new(1, 3, "label1"};
 *      job_t* j4 = job_new(1, 3, "label2"};
 *      job_t* j5 = job_new(2, 3, "label2"};
 *
 *      bool b1 = job_is_equal(j1, j2); // true
 *      bool b2 = job_is_equal(j2, j3); // false
 *      bool b3 = job_is_equal(j3, j4); // false
 *      bool b4 = job_is_equal(j4, j5); // false
 *
 * Parameters:
 * j1 - pointer to first job to compare
 * j2 - pointer to second job to compare
 *
 * Return:
 * True if j1 and j2 are equal: j1->id == j2->id and j1->pid == j2->pid and 
 * the job labels are equal according to string comparison, false otherwise.
 * Two NULL pointers are considered equal.
 */
bool job_is_equal(job_t* j1, job_t* j2);

/* 
 * job_init(job_t* job)
 * 
 * If job is not NULL, set the fields of the job pointed to by the job
 * parameter to the following values:
 *      job->pid set to 0
 *      job->id set to 0
 *      job->label array zeroed (each element of the array set to 0)
 * 
 * If job is NULL, this function has no effect.
 *
 * Parameters:
 * job - pointer to the job to initialise
 */
void job_init(job_t* job);
 
/*
 * job_set(job_t* job, pid_t pid, unsigned int id, const char* label)
 * 
 * Set the given non-null job with the values for the given pid, id and 
 * label. The label is copied to the given job's label field. Calling this 
 * function sets all fields of a job.
 *
 * The properties of the label field are preserved by this function. That is,
 * the job's label field will be a string of length exactly MAX_NAME_SIZE - 
 * (with padding or truncation as necessary).
 * 
 * Parameters:
 * job - a non-NULL pointer to the job to update
 * pid - the value to set the job process id to
 * id - the value to set the job id to
 * label - the label to use to set the job. The label field of the job
 *      will start with this label and be padded or truncated to 
 *      string length MAX_NAME_SIZE - 1 as described for job_new
 *
 * Return:
 * On success: the job pointer is returned. If job is NULL, this fucntion has
 * no effect and the NULL pointer is returned.
 *
 * Note: this function does not dynamically allocate memory
 */
job_t* job_set(job_t* job, pid_t pid, unsigned int id, const char* label);

/*
 * job_delete(job_t* job);
 * 
 * Delete a job struct that has been dynamically allocated by job_new.
 *
 * If job is NULL this function has no effect.
 *
 * Usage: see job_new
 *
 * Parameters:
 * job - a pointer to a job struct allocated by job_new. 
 *
 * Errors: it is an error to pass a pointer to a job that has not been 
 * dynamically allocated and this will cause program termination.
 */
void job_delete(job_t* job);

#endif