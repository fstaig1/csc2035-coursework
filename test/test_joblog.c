/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "test_joblog.h"
#include "procs4tests.h"
#include "../joblog.h"

#define LOG_FILES 4
#define TEST_ENTRY_NUM 11
#define PRESERVE_LOG_OPT "--log-visible"
#define PRESERVE_LOG_SIZE 16


static char* log_fname[LOG_FILES] = {
    "out/bwait_cons0000000.txt",
    "out/bwait_prod0000001.txt",
    "out/bwait_cons0000002.txt",
    "out/bwait_prod0000003.txt"
};

static char* job_label[TEST_ENTRY_NUM] = {
    "*******************************",
    "a******************************",
    "ab*****************************",
    "abc****************************",
    "abcd***************************",
    "abcdefghijklmnopqrstuvwxyz*****",
    "abcdefghijklmnopqrstuvwxyz0****",
    "abcdefghijklmnopqrstuvwxyz01***",
    "abcdefghijklmnopqrstuvwxyz012**",
    "abcdefghijklmnopqrstuvwxyz0123*",
    "abcdefghijklmnopqrstuvwxyz01234",
};

int main(int argc, char** argv) {
    int preserve_logs = 0;
    
    for (int i = 0; i < argc; i++) {
        if (!strncmp(argv[i], PRESERVE_LOG_OPT, PRESERVE_LOG_SIZE)) {
            preserve_logs = 1;
            
            printf(
            "***************************************************************\n"
            "WARNING: the --log-visible option has been selected. Logs will\n"
            "be preserved in the out directory and test_joblog_delete will\n"
            "be a null test and have no effect. To run test_joblog_delete,\n"
            "run the test without the --log-visible option.\n"
            "***************************************************************\n"
            );
            break;
        }
    }
        
    return munit_suite_main(&suite, &preserve_logs, argc, argv);
}

void* test_setup(const MunitParameter params[], void* user_data) {
    proc_t* p = new_test_proc(91);
    p->is_init = true;
    
    joblog_init(p);
    
    proc_delete(p);
    
    errno = 0;

    return user_data;
}

void test_tear_down(void* fixture) {
    int* preserve_logs = (int*) fixture;
    
    if (!*preserve_logs) {
        for (int i = 0; i < LOG_FILES; i++)
            unlink(log_fname[i]);
    }
    
    errno = 0;
}

void write_entries(pid_t cp_id, bool test_errno) {
    job_t job;
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++) {
        int init_errno = errno;
        job.pid = cp_id % 2 ? cp_id : i + 1;
        job.id = i;
        strncpy(job.label, job_label[i], MAX_NAME_SIZE - 1);
        job.label[ MAX_NAME_SIZE - 1] = '\0';
               
        proc_t* proc = new_test_proc(cp_id);
        
        joblog_write_entry(proc, &job);
        
        if (test_errno) assert_int(errno, ==, init_errno);
                
        proc_delete(proc);
    }
}

MunitResult test_sequential_joblog_read_entry(pid_t cp_id, 
    char wentry[TEST_ENTRY_NUM][JOBLOG_ENTRY_SIZE], bool dynamic_alloc, 
    bool test_errno) {
    proc_t* proc = new_test_proc(cp_id);
    
    char local_buf[JOBLOG_ENTRY_SIZE];
    char* rentry = NULL;
    char* buf = dynamic_alloc ? NULL : local_buf;
    
    int i = 0;
    int init_errno = errno;
    
    while ((rentry = joblog_read_entry(proc, i, buf))) {
        munit_logf(MUNIT_LOG_DEBUG, "Read entry %d: %s", i, rentry);
        
        assert_not_null(rentry);
        
        if (dynamic_alloc)
            assert_ptr_not_equal(rentry, local_buf);
        else
            assert_ptr_equal(rentry, local_buf);
            
        assert_string_equal(rentry, wentry[i]);
        
        if (dynamic_alloc) free(rentry);
        i++;
        if (test_errno) assert_int(errno, ==, init_errno);
    }
    
    assert_int(i, ==, TEST_ENTRY_NUM);
    
    proc_delete(proc); 

    return MUNIT_OK;
}

MunitResult test_random_joblog_read_entry(pid_t cp_id, 
    char wentry[TEST_ENTRY_NUM][JOBLOG_ENTRY_SIZE], bool dynamic_alloc, 
    bool test_errno) {
    proc_t* proc = new_test_proc(cp_id);
    
    char local_buf[JOBLOG_ENTRY_SIZE];
    char* buf = dynamic_alloc ? NULL : local_buf;
    
    int i = 0;
    int init_errno = errno;
    
    while (i < (TEST_ENTRY_NUM * 2)) {
        int entry_num = munit_rand_int_range(0, TEST_ENTRY_NUM - 1);
        
        char* rentry = joblog_read_entry(proc, entry_num, buf);
        munit_logf(MUNIT_LOG_DEBUG, "Read entry %d: %s", entry_num, rentry);
        
        assert_not_null(rentry);
        
        if (dynamic_alloc)
            assert_ptr_not_equal(rentry, local_buf);
        else
            assert_ptr_equal(rentry, local_buf);
        
        assert_string_equal(rentry, wentry[entry_num]);

        if (dynamic_alloc) free(rentry);
        i++;
        if (test_errno) assert_int(errno, ==, init_errno);
    }
    
    
    
    proc_delete(proc); 

    return MUNIT_OK;
}

MunitResult test_cpid_joblog_write_entry(pid_t cp_id) {
    errno = 0;
    write_entries(cp_id, false);
    
    char test_entry_fmt[JOBLOG_ENTRY_SIZE];
    strncpy(test_entry_fmt, JOBLOG_ENTRY_FMT, JOBLOG_ENTRY_SIZE - 1);
    test_entry_fmt[JOBLOG_ENTRY_SIZE - 1] = '\0';
    
    FILE* lf = fopen(log_fname[cp_id], "r");
    
    if (!lf) 
        return MUNIT_FAIL;
    
    char actual[JOBLOG_ENTRY_SIZE];
    char expected[JOBLOG_ENTRY_SIZE];
    int i = 0;
    while (i < TEST_ENTRY_NUM && fgets(actual, JOBLOG_ENTRY_SIZE, lf)) {
        actual[JOBLOG_ENTRY_SIZE - 1] = '\0';
        
        munit_logf(MUNIT_LOG_DEBUG, "actual entry: %s", actual);
        
        snprintf(expected, JOBLOG_ENTRY_SIZE, test_entry_fmt, 
            cp_id % 2 ? cp_id : i + 1, i, job_label[i]);

        assert_string_equal(actual, expected);
        i++;
        fgetc(lf); // consume newline
    }
    
    assert_int(i, ==, TEST_ENTRY_NUM);
    
    fclose(lf);

    return MUNIT_OK;
}

MunitResult test_cpid_joblog_read_entry(pid_t cp_id, bool dynamic_alloc, 
    bool test_errno, bool sequential) {
    char test_entry_fmt[JOBLOG_ENTRY_SIZE];
    strncpy(test_entry_fmt, JOBLOG_ENTRY_FMT, JOBLOG_ENTRY_SIZE - 1);
    test_entry_fmt[JOBLOG_ENTRY_SIZE - 1] = '\0';

    char wentry[TEST_ENTRY_NUM][JOBLOG_ENTRY_SIZE];
    FILE* lf = fopen(log_fname[cp_id], "w");
    
    if (!lf)
        return MUNIT_FAIL;
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++) {
        snprintf(wentry[i], JOBLOG_ENTRY_SIZE, test_entry_fmt, 
            cp_id % 2 ? cp_id : i + 1, i, job_label[i]);
        munit_logf(MUNIT_LOG_DEBUG, "Writing wentry[%d]: %s", i, wentry[i]);
        fprintf(lf, "%s\n", wentry[i]);
    }
    
    fclose(lf);
    
    return sequential 
            ? test_sequential_joblog_read_entry(cp_id, wentry, dynamic_alloc,
                test_errno)
            : test_random_joblog_read_entry(cp_id, wentry, dynamic_alloc,
                test_errno);
}

MunitResult test_joblog_write_entry_cpid0(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write_entry(0);
}    

MunitResult test_joblog_write_entry_cpid1(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write_entry(1);
}    

MunitResult test_joblog_write_entry_cpid2(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write_entry(2);
}    

MunitResult test_joblog_write_entry_cpid3(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write_entry(3);
}    

MunitResult test_joblog_write_entry_errno(const MunitParameter params[], 
    void* fixture) {
    errno = 0;
    write_entries(0, true); 
    
    return MUNIT_OK;
}    

MunitResult test_joblog_write_entry_null(const MunitParameter params[], 
    void* fixture) {
    int init_errno = errno;
    
    job_t j;
    j.pid = 0;
    j.id = 0;
    strncpy(j.label, job_label[0], MAX_NAME_SIZE - 1);
    j.label[ MAX_NAME_SIZE - 1] = '\0';
    
    joblog_write_entry(NULL, &j);
    
    assert_int(errno, ==, init_errno);
    
    proc_t* proc = new_test_proc(98);
    
    joblog_write_entry(proc, NULL);
    
    assert_int(errno, ==, init_errno);
    
    proc_delete(proc);

    return MUNIT_OK;
}

MunitResult test_joblog_read_entry_cpid0(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(0, true, false, true);
}

MunitResult test_joblog_read_entry_cpid1(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(1, true, false, true);
}

MunitResult test_joblog_read_entry_cpid2(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(2, true, false, true);
}

MunitResult test_joblog_read_entry_cpid3(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(3, true, false, true);
}

MunitResult test_joblog_read_entry_stack(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(0, false, false, true);
}

MunitResult test_joblog_read_entry_rand(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(0, true, false, false);
}

MunitResult test_joblog_read_entry_errno(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read_entry(0, true, true, true);
}

MunitResult test_joblog_read_entry_bounds(const MunitParameter params[],
    void* fixture) {
    proc_t* proc = new_test_proc(0);
    
    FILE* lf = fopen(log_fname[0], "w");
    
    if (!lf)
        return MUNIT_FAIL;
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++)
        fprintf(lf, JOBLOG_ENTRY_FMT, i, i + 1, job_label[i]);
    
    fclose(lf);
    
    int init_errno = errno;
    char* rentry = joblog_read_entry(proc, -1, NULL);

    assert_null(rentry);
    assert_int(errno, ==, init_errno);
    
    rentry = joblog_read_entry(proc, TEST_ENTRY_NUM, NULL);

    assert_null(rentry);
    assert_int(errno, ==, init_errno);
    
    proc_delete(proc);

    return MUNIT_OK;
}

MunitResult test_joblog_read_entry_null(const MunitParameter params[],
    void* fixture) {
    int init_errno = errno;
    
    char* x = joblog_read_entry(NULL, 0, NULL);
    
    assert_null(x);
    assert_int(errno, ==, init_errno);
    
    proc_t* proc = new_test_proc(99);
    
    x = joblog_read_entry(proc, 0, NULL);
        
    assert_null(x);
    assert_int(errno, ==, init_errno);
    
    proc_delete(proc);
    
    return MUNIT_OK;
}

MunitResult test_joblog_delete(const MunitParameter params[],
    void* fixture) {
    int* preserve_logs = (int*) fixture;
    
    if (*preserve_logs)
        return MUNIT_OK;
    
    for (int i = 0; i < LOG_FILES; i++) {
        FILE* lf = fopen(log_fname[i], "w");
        fclose(lf);
        
        if (access(log_fname[i], F_OK) == -1) 
            return MUNIT_FAIL;
        
        proc_t* proc = new_test_proc(i);   
        int errno_init = errno;
        
        joblog_delete(proc);
        
        assert_int(errno, ==, errno_init);
        
        proc_delete(proc);
        
        assert_int(access(log_fname[i], F_OK), ==, -1);
        assert_int(errno, ==, ENOENT);  
    }
    
    errno = 0;
    
    return MUNIT_OK;
}
