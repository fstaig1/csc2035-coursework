/******** DO NOT EDIT THIS FILE ********/
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <errno.h>
#include "test_jobqueue_common.h"
#include "test_sem_jobqueue.h"
#include "../sim_config.h"
#include "../shobject_name.h"
#include "../sem_jobqueue.h"
#include "procs4tests.h"

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

void* test_setup(const MunitParameter params[], void* user_data) {
    test_jq_t* test_jq = (test_jq_t*) malloc(sizeof(test_jq_t));
    
    sem_jobqueue_t* q = sem_jobqueue_new(new_init_proc());
    
    test_jq->q = q;
    jobqueue_t* jq = (jobqueue_t*) q->ijq->addr;

    // assert valid queue
    assert_queue_initialised(jq);
    
    test_jq->head = &jq->head;
    test_jq->tail = &jq->tail;
    test_jq->buf_size = &jq->buf_size;
    test_jq->jobs = jq->jobs;
    test_jq->capacity = (size_t (*)(void*)) sem_jobqueue_capacity;
    test_jq->is_full = (bool (*)(void*)) sem_jobqueue_is_full;
    test_jq->is_empty = (bool (*)(void*)) sem_jobqueue_is_empty;
    test_jq->enqueue = (void (*)(void*, job_t*)) sem_jobqueue_enqueue;
    test_jq->dequeue = (job_t* (*)(void*, job_t*)) sem_jobqueue_dequeue;
    test_jq->peekhead = (job_t* (*)(void*, job_t*)) sem_jobqueue_peekhead;
    test_jq->peektail = (job_t* (*)(void*, job_t*)) sem_jobqueue_peektail;
    
    errno = 0;
    
    return test_jq;
}

static void del_sem(sem_t* sem, const char* lab) {
    char name[MAX_NAME_SIZE];
    sem_close(sem);
    shobject_name(name, lab);
    sem_unlink(name);
}

static void del_sjq(sem_jobqueue_t* q) {
    del_sem(q->mutex, "sjq.mutex");
    del_sem(q->full, "sjq.full");
    del_sem(q->empty, "sjq.empty");

    ipc_jobqueue_delete(q->ijq);
    free(q);
}

void test_tear_down(void* fixture) {
    test_jq_t* test_jq = (test_jq_t*) fixture;
    sem_jobqueue_t* q = (sem_jobqueue_t*) test_jq->q;
   
    proc_t* p = q->ijq->proc;
    del_sjq(q);    
    proc_delete(p);
    free(test_jq);
}

static MunitResult test_no_semfailure(MunitResult result) {
    if (result == MUNIT_OK)
        assert_int(errno, ==, 0);
    
    return result;
}

MunitResult test_sem_jobqueue_capacity(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(
        test_jq_capacity((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_capacity_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_capacity_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_dequeue_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_dequeue_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_enqueue_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_enqueue_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_is_empty_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_is_empty_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_is_full_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_is_full_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_peekhead_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_peekhead_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_peektail_null(const MunitParameter params[], 
    void* fixture) {
    return test_no_semfailure(test_jq_peektail_null((test_jq_t*) fixture));
}

MunitResult test_sem_jobqueue_2proc_enqueue_dequeue(
    const MunitParameter params[], void* fixture) {
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        sem_jobqueue_t* sjq = sem_jobqueue_new(cp);

        assert_not_null(sjq);
        
        for (int i = 0; i < sem_jobqueue_capacity(sjq) * 2; i++) {
            job_t expj;
            set_job(&expj, i + 1, i, NULL);
            job_t dqj;

            errno = 0;
            assert_true(equal_jobs(sem_jobqueue_dequeue(sjq, &dqj), &expj));
            assert_int(errno, ==, 0);
        }
        
        
        del_sjq(sjq);
        proc_delete(cp);
        
        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();
        sem_jobqueue_t* sjq = sem_jobqueue_new(pp);

        assert_not_null(sjq);

        for (int i = 0; i < sem_jobqueue_capacity(sjq) * 2; i++) {
            job_t j;
            set_job(&j, i + 1, i, NULL);
            errno = 0;
            sem_jobqueue_enqueue(sjq, &j);
            assert_int(errno, ==, 0);
        } 
        
        waitpid(pid, &child_stat, 0);
        assert_false(sem_jobqueue_is_full(sjq));
        assert_true(sem_jobqueue_is_empty(sjq));
        
        del_sjq(sjq);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
    }

    return MUNIT_OK;
}

MunitResult test_sem_jobqueue_2proc_peekhead(const MunitParameter params[], 
    void* fixture) {
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        sem_jobqueue_t* sjq = sem_jobqueue_new(cp);

        assert_not_null(sjq);

        for (int i = 0; i < sem_jobqueue_capacity(sjq); i++) {
            job_t expj;
            job_t pj;
            set_job(&expj, i + 1, i, NULL);
            sem_jobqueue_enqueue(sjq, &expj);
            errno = 0;
            assert_true(equal_jobs(sem_jobqueue_peektail(sjq, &pj), &expj));
            assert_int(errno, ==, 0);

            printf(".");
            fflush(stdout);
            delay_ms(50);
        } 
        
        printf("\n");
        
        delay_ms(500);
        del_sjq(sjq);
        proc_delete(cp);
        
        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();
        sem_jobqueue_t* sjq = sem_jobqueue_new(pp);

        assert_not_null(sjq);

        int i = 0;
        int count = 0;
        
        while (i < sem_jobqueue_capacity(sjq)) {
            errno = 0;
            job_t h;
            job_t* hp = sem_jobqueue_peekhead(sjq, &h);
            assert_int(errno, ==, 0);
            if (!hp)
                delay_ms(10);
            else {
                assert_ptr_equal(hp, &h);
                job_t exp_j;
                set_job(&exp_j, i + 1, i, NULL);
                assert_true(equal_jobs(hp, &exp_j));
                
                errno = 0;
                job_t dq_j;
                assert_true(equal_jobs(sem_jobqueue_dequeue(sjq, &dq_j),
                    &exp_j));
                assert_int(errno, ==, 0);
                
                i++;
                count++;
            }
        }
        
        assert_int(count, ==, sem_jobqueue_capacity(sjq));
        assert_false(sem_jobqueue_is_full(sjq));
        assert_true(sem_jobqueue_is_empty(sjq));
       
        waitpid(pid, &child_stat, 0);

        del_sjq(sjq);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
    }

    return MUNIT_OK;
}

MunitResult test_sem_jobqueue_2proc_peektail(const MunitParameter params[], 
    void* fixture) {
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        sem_jobqueue_t* sjq = sem_jobqueue_new(cp);

        assert_not_null(sjq);

        for (int i = 0; i < sem_jobqueue_capacity(sjq); i++) {
            job_t j;
            set_job(&j, i + 1, i, NULL);
            errno = 0;
            sem_jobqueue_enqueue(sjq, &j);
            assert_int(errno, ==, 0);
            printf(".");
            fflush(stdout);
            delay_ms(20);
        } 
        
        printf("\n");
        
        del_sjq(sjq);
        proc_delete(cp);
        
        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();
        sem_jobqueue_t* sjq = sem_jobqueue_new(pp);

        assert_not_null(sjq);

        waitpid(pid, &child_stat, 0);

        assert_true(sem_jobqueue_is_full(sjq));
        assert_false(sem_jobqueue_is_empty(sjq));

        int i = 0;
        int capacity = sem_jobqueue_capacity(sjq);
        job_t exp_j;
        set_job(&exp_j, capacity, capacity - 1, NULL);       
        
        while (i < sem_jobqueue_capacity(sjq)) {
            errno = 0;
            job_t jt;
            (void) sem_jobqueue_peektail(sjq, &jt);
            assert_int(errno, ==, 0);            
            assert_true(job_is_equal(&jt, &exp_j));
            
            errno = 0;            
            job_t exp_dj;
            job_t dj;
            set_job(&exp_dj, i + 1, i, NULL);
            assert_true(job_is_equal(sem_jobqueue_dequeue(sjq, &dj), &exp_dj));
            assert_int(errno, ==, 0);

            i++;
        }
        
        assert_false(sem_jobqueue_is_full(sjq));
        assert_true(sem_jobqueue_is_empty(sjq));
        
        del_sjq(sjq);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
    }

    return MUNIT_OK;
}
