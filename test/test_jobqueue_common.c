/******** DO NOT EDIT THIS FILE ********/
#include "test_jobqueue_common.h"
#include <stdio.h>

static bool equal_jobs(job_t* j1, job_t* j2) {
    return j1->pid == j2->pid && j1->id == j2->id 
            && !strncmp(j1->label, j2->label, MAX_NAME_SIZE - 1);
}

static void init_job(job_t* job) {
    job->pid = 0;
    job->id = 0;
    
    memset(job->label, 0, MAX_NAME_SIZE);
}

static void set_job(job_t* j, pid_t pid, unsigned int id, const char* label) {
    j->pid = pid;
    j->id = id;
    
    strncpy(j->label, label ? label : "*******************************",
        MAX_NAME_SIZE - 1);
    j->label[MAX_NAME_SIZE - 1] = '\0';
}

static void copy_job(job_t* j1, job_t* j2) {
    set_job(j1, j2->pid, j2->id, j2->label);
}

static bool head_first_job(test_jq_t* test_jq, job_t* expected_job) {
    // first job is the job at the head
    return equal_jobs(&test_jq->jobs[*test_jq->head], expected_job);
}

static bool tail_last_job(test_jq_t* test_jq, job_t* expected_job) {
    // last job is the job behind the tail
    int last_posn = (*test_jq->tail + *test_jq->buf_size - 1) %  
                            *test_jq->buf_size;
    
    return equal_jobs(&test_jq->jobs[last_posn], expected_job);
}

static bool tq_is_full(test_jq_t* test_jq) {
    return !test_jq->q || 
            *test_jq->head == (*test_jq->tail + 1) % *test_jq->buf_size;
}

static bool tq_is_empty(test_jq_t* test_jq) {
    return !test_jq->q || *test_jq->head == *test_jq->tail;
}

static job_t* tq_dequeue(test_jq_t* test_jq, job_t* j) {
    if (tq_is_empty(test_jq)) 
        return NULL;
        
    job_t* hj = &test_jq->jobs[*test_jq->head];
    
    copy_job(j, hj);
    init_job(hj);
    
    *test_jq->head = (*test_jq->head + 1) % *test_jq->buf_size;
    
    return j;
}

static void tq_enqueue(test_jq_t* test_jq, job_t* j) {
    if (tq_is_full(test_jq))
        return;
        
    job_t* tj = &test_jq->jobs[*test_jq->tail];
    
    copy_job(tj, j);

    *test_jq->tail = (*test_jq->tail + 1) % *test_jq->buf_size;
}

static bool queue_not_empty(test_jq_t* test_jq) {
    if (*test_jq->head == *test_jq->tail)
        return false;
    
    job_t ij;
    init_job(&ij);
    
    bool is_empty = true;
    int i = 0;
    
    while (is_empty && i < *test_jq->buf_size) {
        is_empty = equal_jobs(&test_jq->jobs[i], &ij);
        i++;
    }
    
    return !is_empty || equal_jobs(&test_jq->jobs[*test_jq->tail], &ij);
}

static bool queue_is_empty(test_jq_t* test_jq) {
    return tq_is_empty(test_jq) 
            && jobs_initialised(test_jq->jobs, *test_jq->buf_size);
}

static bool queue_not_full(test_jq_t* test_jq) {
    if (*test_jq->head != (*test_jq->tail + 1) % *test_jq->buf_size) {
    
        job_t ij;
        init_job(&ij);

        return equal_jobs(&test_jq->jobs[*test_jq->tail], &ij);
    }
    
    return false;
}

static bool queue_is_full(test_jq_t* test_jq) {
    if (tq_is_full(test_jq)) {
        job_t ij;
        init_job(&ij);

        return !equal_jobs(&test_jq->jobs[*test_jq->head], &ij)
                && equal_jobs(&test_jq->jobs[*test_jq->tail], &ij);
    } 
    
    return false;
}

static bool fill_queue(test_jq_t* test_jq) {
    int i = 0;
    
    while (!tq_is_full(test_jq)) {
        job_t j;
        set_job(&j, i + 1, i, NULL);
        tq_enqueue(test_jq, &j);
        i++;
    }

    return i == *test_jq->buf_size - 1 && queue_not_empty(test_jq)
            && queue_is_full(test_jq);
}

bool jobs_initialised(job_t* jobs, size_t buf_size) {
    job_t ij;
    init_job(&ij);
    int i = 0;
    bool initialised = true;
    
    while (i < buf_size && initialised) {
        initialised = equal_jobs(&jobs[i], &ij);
        i++;
    }
    
    return initialised;
}

MunitResult test_jq_capacity(test_jq_t* test_jq) {
    assert_int(test_jq->capacity(test_jq->q), ==, *test_jq->buf_size - 1);
   
    return MUNIT_OK;
}

MunitResult test_jq_capacity_null(test_jq_t* test_jq) {
    assert_int(test_jq->capacity(NULL), ==, 0);
   
    return MUNIT_OK;
}

MunitResult test_jq_dequeue_fullq(test_jq_t* test_jq) {
    // tests dequeueing from full queue does not change queue state
    assert_true(jobs_initialised(test_jq->jobs, *test_jq->buf_size));
    assert_true(fill_queue(test_jq));
    
    int i = 0;
    
    
    while (!tq_is_empty(test_jq)) {
        job_t actual_j;
        job_t expected_j;
        set_job(&expected_j, i + 1, i, NULL);
        
        job_t* dq = test_jq->dequeue(test_jq->q, &actual_j);       
        
        assert_true(equal_jobs(dq, &expected_j));
        assert_ptr_equal(dq, &actual_j);
        assert_ptr_not_equal(dq, &expected_j);
        
        i++;
    }
    
    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_dequeue_inout(test_jq_t* test_jq) {
    int ops = *test_jq->buf_size;
    ops += ops / 2;
    int i = 0;
    for (i = 0; i < ops; i++) {
        job_t actual_j;
        job_t expected_j;
        set_job(&expected_j, i + 1, i, NULL);
        
        tq_enqueue(test_jq, &expected_j);
        
        job_t* dq = test_jq->dequeue(test_jq->q, &actual_j);
        
        assert_true(equal_jobs(dq, &expected_j));
        assert_ptr_equal(dq, &actual_j);
        assert_ptr_not_equal(dq, &expected_j);
    }
    
    assert_int(i, ==, ops);

    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_dequeue_emptyq(test_jq_t* test_jq) {
    // tests dequeuing from empty queue does not change queue state
    int buf_size = *test_jq->buf_size;
    int test_dequeues = buf_size + (buf_size / 3);
    
    int head = *test_jq->head;
    int tail = *test_jq->tail;
        
    job_t ij;
    init_job(&ij);
    
    for (int i = 0; i < buf_size; i++)
        assert_true(equal_jobs(&test_jq->jobs[i], &ij));

    job_t j;
    for (int i = 0; i < test_dequeues; i++)
        assert_null(test_jq->dequeue(test_jq->q, &j));

    assert_true(queue_is_empty(test_jq));


    for (int i = 0; i < buf_size; i++)
        assert_true(equal_jobs(&test_jq->jobs[i], &ij));
        
    assert_int(*test_jq->head, ==, head);
    assert_int(*test_jq->tail, ==, tail);
    
    return MUNIT_OK;
}

MunitResult test_jq_dequeue_heap(test_jq_t* test_jq) {
    assert_true(fill_queue(test_jq));
    
    int i = 0;
    
    while (!tq_is_empty(test_jq)) {
        job_t expected_j;
        set_job(&expected_j, i + 1, i, NULL);
        
        job_t* hj = &test_jq->jobs[*test_jq->head];
        job_t hjval;
        copy_job(&hjval, hj);
          
        job_t* dq = test_jq->dequeue(test_jq->q, NULL);       
        
        assert_true(equal_jobs(dq, &expected_j));
        assert_true(equal_jobs(dq, &hjval));
        assert_ptr_not_equal(dq, &expected_j);
        assert_ptr_not_equal(dq, hj);
        
        free(dq); // fail if not dyamically allocated
        i++;
    }
    
    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));

    
    return MUNIT_OK;
}

MunitResult test_jq_dequeue_null(test_jq_t* test_jq) {
    job_t j;
    
    assert_null(test_jq->dequeue(NULL, &j));

    return MUNIT_OK;
}

MunitResult test_jq_enqueue_tofull(test_jq_t* test_jq) {
    int i = 0;
    job_t j;

    for (i = 0; i < *test_jq->buf_size - 1; i++) {
        set_job(&j, i + 1, i, NULL);
        test_jq->enqueue(test_jq->q, &j);
    }
    
    assert_int(i, ==, *test_jq->buf_size - 1);

    assert_true(queue_not_empty(test_jq));
    assert_true(queue_is_full(test_jq));
    
    // check first and last jobs
    job_t expected_first;
    job_t expected_last;
    set_job(&expected_first, 1, 0, NULL);
    set_job(&expected_last, i, i - 1, NULL);
    assert_true(head_first_job(test_jq, &expected_first)); 
    assert_true(tail_last_job(test_jq, &expected_last));

    i = 0;
    
    while (!tq_is_empty(test_jq)) {
        job_t expected_j;
        job_t actual_j;
        set_job(&expected_j, i + 1, i, NULL);
        
        job_t* dq = tq_dequeue(test_jq, &actual_j);

        assert_true(equal_jobs(dq, &expected_j));
        assert_ptr_equal(dq, &actual_j);
        assert_ptr_not_equal(dq, &expected_j);
        assert_ptr_not_equal(dq, &j);
        i++;
    }
    
    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));

    return MUNIT_OK;
}

MunitResult test_jq_enqueue_inout(test_jq_t* test_jq) {
    int ops = *test_jq->buf_size;
    ops += ops / 2;
    int i = 0;
    for (i = 0; i < ops; i++) {
        job_t expected_j;
        job_t actual_j;
        set_job(&expected_j, i + 1, i, NULL);
        
        test_jq->enqueue(test_jq->q, &expected_j);
        
        job_t* dq = tq_dequeue(test_jq, &actual_j);
        
        assert_true(equal_jobs(dq, &expected_j));
        assert_ptr_equal(dq, &actual_j);
        assert_ptr_not_equal(dq, &expected_j);
    }
    
    assert_int(i, ==, ops);

    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult  test_jq_enqueue_fullq(test_jq_t* test_jq) {
    assert_true(fill_queue(test_jq));

    job_t saved_jobs[*test_jq->buf_size];
    int head = *test_jq->head;
    int tail = *test_jq->tail;
    int buf_size = *test_jq->buf_size;
    
    for (int i = 0; i < buf_size; i++)
        copy_job(&saved_jobs[i], &test_jq->jobs[i]);
    
    int test_enqueues = buf_size + (buf_size / 3);
    
    // tests enqueuing to full queue does not change queue state
    for (int i = 0; i < test_enqueues; i++) {
        job_t j;
        set_job(&j, i + 20, i * 10, NULL);
        test_jq->enqueue(test_jq->q, &j);
    }
    
    for (int i = 0; i < buf_size; i++)
        assert_true(equal_jobs(&test_jq->jobs[i], &saved_jobs[i]));
        
    assert_int(head, ==, *test_jq->head);
    assert_int(tail, ==, *test_jq->tail);
    assert_int(buf_size, ==, *test_jq->buf_size);
    
    assert_true(queue_is_full(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_enqueue_null(test_jq_t* test_jq) {
    job_t j;
    
    test_jq->enqueue(NULL, &j);
    
    job_t saved_jobs[*test_jq->buf_size];
    int head = *test_jq->head;
    int tail = *test_jq->tail;
    int buf_size = *test_jq->buf_size;
    
    for (int i = 0; i < buf_size; i++)
        copy_job(&saved_jobs[i], &test_jq->jobs[i]);

    test_jq->enqueue(test_jq->q, NULL);

    for (int i = 0; i < buf_size; i++)
        assert_true(equal_jobs(&test_jq->jobs[i], &saved_jobs[i]));
        
    assert_int(head, ==, *test_jq->head);
    assert_int(tail, ==, *test_jq->tail);
    assert_int(buf_size, ==, *test_jq->buf_size);

    return MUNIT_OK;
}

MunitResult test_jq_is_empty(test_jq_t* test_jq) {
    assert_true(test_jq->is_empty(test_jq->q));
    assert_true(queue_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_empty_notempty(test_jq_t* test_jq) {
    for (int i = 0; i < *test_jq->buf_size - 1; i++) {
        job_t j;
        job_set(&j, i, i, NULL);
        tq_enqueue(test_jq, &j);
        assert_false(test_jq->is_empty(test_jq->q));
        assert_true(queue_not_empty(test_jq));
    }
        
    return MUNIT_OK;
}

MunitResult test_jq_is_empty_null(test_jq_t* test_jq) {
    assert_true(test_jq->is_empty(NULL));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_full_empty(test_jq_t* test_jq) {
    assert_false(test_jq->is_full(test_jq->q));
    assert_true(queue_not_full(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_is_full_filling(test_jq_t* test_jq) {
    for (int i = 0; i < *test_jq->buf_size - 1; i++) {
        job_t j;
        job_set(&j, i, i, NULL);
        tq_enqueue(test_jq, &j);
        if (i < *test_jq->buf_size - 2) {
            assert_false(test_jq->is_full(test_jq->q));
            assert_true(queue_not_full(test_jq));
        }
    }
    
    assert_true(test_jq->is_full(test_jq->q));
    assert_true(queue_is_full(test_jq));
        
    return MUNIT_OK;
}

MunitResult test_jq_is_full_null(test_jq_t* test_jq) {
    assert_true(test_jq->is_full(NULL));
    
    return MUNIT_OK;
}

MunitResult test_jq_peekhead_empty(test_jq_t* test_jq) {
    job_t j;
    
    assert_null(test_jq->peekhead(test_jq->q, &j));
    return MUNIT_OK;
}

MunitResult test_jq_peekhead_full(test_jq_t* test_jq) {
    int i = 0;
    job_t expected_j;
    job_set(&expected_j, 1, 0, NULL);
    
    while (!tq_is_full(test_jq)) {
        job_t j;
        job_set(&j, i + 1, i, NULL);
        tq_enqueue(test_jq, &j);
    
        job_t h1;
        job_t h2;
        
        job_t* h1ptr = test_jq->peekhead(test_jq->q, &h1);
        
        assert_true(head_first_job(test_jq, h1ptr));
        
        job_t* h2ptr = test_jq->peekhead(test_jq->q, &h2);
        
        assert_true(equal_jobs(h1ptr, &expected_j));
        assert_true(equal_jobs(h1ptr, h2ptr));
        
        assert_ptr_equal(h1ptr, &h1);
        assert_ptr_equal(h2ptr, &h2);
        assert_ptr_not_equal(h1ptr, h2ptr);
        i++;
    }
    
    assert_true(queue_is_full(test_jq));

    i = 0;
    
    // while not empty
    while (!tq_is_empty(test_jq)) {
        job_t j;
        job_set(&j, i + 1, i, NULL);

        job_t h1;
        job_t h2;

        job_t* h1ptr = test_jq->peekhead(test_jq->q, &h1);
        
        assert_true(head_first_job(test_jq, h1ptr));
        
        job_t* h2ptr = test_jq->peekhead(test_jq->q, &h2);

        assert_true(equal_jobs(h1ptr, &j));
        assert_true(equal_jobs(h1ptr, h2ptr));
        
        assert_ptr_equal(h1ptr, &h1);
        assert_ptr_equal(h2ptr, &h2);
        assert_ptr_not_equal(h1ptr, h2ptr);

        (void) tq_dequeue(test_jq, &h2);
        
        i++;
    }
    
    job_t j;
    
    assert_null(test_jq->peekhead(test_jq->q, &j));

    return MUNIT_OK;
}

MunitResult test_jq_peekhead_heap(test_jq_t* test_jq) {
    assert_true(fill_queue(test_jq));
    
    int i = 0;
    
    while (!tq_is_empty(test_jq)) {
        job_t expected_j;
        set_job(&expected_j, i + 1, i, NULL);
        
        job_t* hj = &test_jq->jobs[*test_jq->head];
        
        job_t* ph = test_jq->peekhead(test_jq->q, NULL);       
        
        assert_true(equal_jobs(ph, &expected_j));
        assert_true(equal_jobs(ph, hj));
        assert_ptr_not_equal(ph, &expected_j);
        assert_ptr_not_equal(ph, hj);
        job_t j;
        
        job_t* dq = tq_dequeue(test_jq, &j);
        
        assert_true(equal_jobs(ph, dq));
        assert_ptr_not_equal(ph, dq);
        assert_ptr_equal(dq, &j);

        free(ph); // fail if not dyamically allocated
              
        i++;
    }
    
    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_peekhead_null(test_jq_t* test_jq) {
    job_t j;
    
    assert_null(test_jq->peekhead(NULL, &j));

    return MUNIT_OK;
}

MunitResult test_jq_peektail_empty(test_jq_t* test_jq) {
    job_t j;
    
    assert_null(test_jq->peektail(test_jq->q, &j));

    return MUNIT_OK;
}

MunitResult test_jq_peektail_full(test_jq_t* test_jq) {
    int i = 0;

    while (!tq_is_full(test_jq)) {
        job_t j;
        job_set(&j, i + 1, i, NULL);
        tq_enqueue(test_jq, &j);
    
        job_t t1;
        job_t t2;
        
        job_t* t1ptr = test_jq->peektail(test_jq->q, &t1);

        assert_true(tail_last_job(test_jq, t1ptr));

        job_t* t2ptr = test_jq->peektail(test_jq->q, &t2);
        
        assert_true(equal_jobs(t1ptr, &j));
        assert_true(equal_jobs(t1ptr, t2ptr));
        
        assert_ptr_equal(t1ptr, &t1);
        assert_ptr_equal(t2ptr, &t2);
        assert_ptr_not_equal(t1ptr, t2ptr);
               
        i++;
    }
    
    assert_true(queue_is_full(test_jq));
    
    job_t expected_j;
    set_job(&expected_j, i, i-1, NULL);
    
    while (!tq_is_empty(test_jq)) {
        job_t t1;
        job_t t2;
        
        job_t* t1ptr = test_jq->peektail(test_jq->q, &t1);
        
        assert_true(tail_last_job(test_jq, t1ptr));
        
        job_t* t2ptr = test_jq->peektail(test_jq->q, &t2);
        
        assert_true(equal_jobs(t1ptr, &expected_j));
        assert_true(equal_jobs(t1ptr, t2ptr));
        
        assert_ptr_equal(t1ptr, &t1);
        assert_ptr_equal(t2ptr, &t2);
        assert_ptr_not_equal(t1ptr, t2ptr);
        
        (void) tq_dequeue(test_jq, &t2);
    }

    job_t j;

    assert_null(test_jq->peektail(test_jq->q, &j));

    return MUNIT_OK;
}

MunitResult test_jq_peektail_heap(test_jq_t* test_jq) {
    assert_true(fill_queue(test_jq));
    
    job_t expected_j;
    set_job(&expected_j, *test_jq->buf_size - 1, *test_jq->buf_size - 2, NULL);
    
    while (!tq_is_empty(test_jq)) {
        job_t* pt = test_jq->peektail(test_jq->q, NULL);       
        
        assert_true(equal_jobs(pt, &expected_j));
        assert_ptr_not_equal(pt, &expected_j);
        free(pt); // fail if not dyamically allocated
        
        job_t j;
        
        (void) tq_dequeue(test_jq, &j);
    }
    
    assert_true(queue_not_full(test_jq));
    assert_true(queue_is_empty(test_jq));
    
    return MUNIT_OK;
}

MunitResult test_jq_peektail_null(test_jq_t* test_jq) {
    job_t j;
    
    assert_null(test_jq->peektail(NULL, &j));

    return MUNIT_OK;
}
